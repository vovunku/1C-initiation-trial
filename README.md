# 1C-initiation-trial
Вступительное испытание на кафедру 1С, 14 апреля 2021.

### Задание
Код задачи: 142

Реализуйте механизм, позволяющий хранить изменения между двумя бинарными файлами.

На вход операции "Рассчитать диф" подаются два бинарных файла ("старый" и "новый"). Операция должна оптимально сформировать файл разницы между ними.

На вход операции "Восстановить" подаётся "старый" файл и файл разницы. Она должна восстановить "новый" файл. 

"Файлы" должны храниться и создаваться на диске, хранение промежуточных данных в оперативной памяти запрещено.

### Build
```
git clone https://github.com/vovunku/1C-initiation-trial.git
cd 1C-initiation-trial
mkdir build
cd build
cmake ../
make
```
Для запуска my_diff потребуются два входных бинарных файла. Запуск производится в формате: ./my_diff [OPTION] file file. Где опции это --difference или -d для создания файла разности и -r или --restore для восстановления нового файла.

### Состояние решения
На момент окончания испытания реализованы следующие части:
1. Простенький командный интерфейс
2. Возможность записи разницы между введенными файлами в result.diff
3. Есть алгоритм восстановления файла по разности и исходному, но он не заимплеменчен,
так как очень много времени понадобилось на работу с байтами(в итоге не получилось считывать числа).

Кроме того я продумал возможные улучшение и пути решения
(был потрачен час на нахождение *хорошего* решения, но оказалось недостаточно времени для его имплементации)

### Пути решения задачи
Бинарные файлы(особенно в больших проектах) могут быть огромных размеров,
поэтому работать за асимптотический квадрат(или произведение длин) - неприемлемо.
Глобально есть три типа изменений - вставка, удаление и изменение.
Есть хорошие алгоритмы(поиска расстояния Левинштейна), которые решают нашу задачу
но работают они за n * m. Было решено использовать эти алгоритмы(так как они оптимальны по памяти)
на небольших файлах. Кроме того! Зачастую изменения происходят на совсем небольших участках(если мы говорим о коде)
В таком случае, можно выбрать размер блока, который далее можно обработать оптимальным алгоритмом. То есть
если мы долго встречаем изменения, то мы можем попытаться использовать наш алгоритм для оптимизации. Кроме того,
Зачастую большие куски могут просто дописываться в конец или середину кода - это тоже можно использовать в качестве эвристики.

### Мое решение
После долгих раздумий я решил заимплементить хотя бы базовую версию - воспринимать любое отличие в файлах как *изменение*.
Для сохранения этой информации я сохраняю место, где я встретил изменение(offset) размер накопленного буффера изменения(buffer.size()) и сам буффер.
Таким образом, для восстановления нужно параллельно идти по старому файлу и изменениям, и примениять учитывая offset.
